---
title: "[1. Node.js에 대해서] 1.3 React Pattern"
date: 2019-05-07 09:46:00
categories: nodejs designpattern


---

## 1.3 React Pattern

Node.js의 비동기 특성의 핵심인 React 패턴을 분석한다. 단일 스레드 아키텍쳐 및 블로킹 I/O와 같은 패턴의 기본 개념을 살펴보고, 이것이 Node.js 플랫폼 전체에 대한 기반을 형성하는 방법을 살펴본다.

### 1.3.1 I/O는 속도가 느리다.

- I/O는 컴퓨터의 기본적인 동작 중에서 가장 느리다.
- I/O는 일반적으로 CPU 측면에서 비용이 많이 들지 않지만, 요청을 보낸 순간부터 작업이 완료되는 순간까지 지연을 동반하게 된다.
- 또한 어플리케이션의 입력은 실시간 채팅 어플리케이션에서 전송 버튼이나 메시지 클릭과 같은 실제 사람의 입력이므로 I/O의 속도와 빈도는 기술적인 면에만 의존하지 않는다. 이는 디스크 또는 네트워크보다 훨씬 더 느리게 진행될 수 있다.

### 1.3.2 Blocking I/O

- 전통적인 블로킹 I/O 프로그래밍에서는 I/O 요청이 해당하는 함수 호출은 작업이 완료될 때까지 스레드의 실행이 차단된다. 
- 디스크 액세스의 경우 몇 밀리 초에서 키를 누르는 것과 같은 사용자 조작으로 생성되는 데이터의 경우 몇 분 또는 그 이상이 걸릴 수 도 있다.

다음 의사 코드는 소켓에 대해 수행되는 일반적인 블로킹 스레드를 보여준다.

```javascript
//데이터를 사용할 수 있을 때까지 스레드가 블록된다.
data = socket.read();
//데이터 사용 가능
print(data);
```

- 각 소켓에서의 모든 I/O 작업이 다른 연결 처리를 차단하기 때문에 블로킹 I/O를 사용하여 구현된 웹 서버가 동일한 스레드에서 여러 연결을 처리할 수 없다.
- 따라서 웹 서버에서 동시성을 처리하기 위한 전통적인 접근 방식은 처리해야 하는 각각의 동시 연결에 대해 새로운 스레드 또는 프로세스를 시작하거나 풀에서 가져온 스레드를 재사용하는 것이다.
- 이렇게 해서 스레드가 I/O 작업으로 차단되어도 분리된 스레드에서 처리되므로 다른 요청의 가용성에는 영향을 미치지 않는다.

아래 그림은 이 시나리오를 보여주고 있다.

![image1](/Users/wook/Desktop/image1.png)

위 이미지는 각 스레드가 관련 연결로부터 새로운 데이터가 수신되기를 기다리는 유휴 상태에 중점을 두고 있다. 예를 들어, 데이터베이스나 파일 시스템과 상호 작용할 때와 같이 모든 유형의 I/O가 요청의 처리를 차단할 수 있다고 생각한다면, 곧 스레드가 얼마나 많이 I/O 조작의 결과를 기다리기 위해 차단되는지 그 횟수를 알 수 있다. 불행히 스레드는 시스템 리소스 측면에서 비용이 싸지 않다. 메모리를 소비하고 컨텍스트 전환을 유발하므로, 각 연결에 대해 대부분의 시간을 사용하지 않으면서 장시간 실행되는 스레드를 사용하는 것은 효율성 측면에서 최상의 절충안은 아니다.

### 1.3.3 Non Blocking I/O

- 대부분의 최신 운영체제는 리소스를 액세스 하는 데에 있어 논 블로킹 I/O 매커니즘을 사용한다.
- 이 운영 모드에서 시스템 호출은 데이터가 읽히거나 쓰여질때까지 기다리지 않고 항상 즉시 반환한다.
- 호출하는 순간에 결과를 사용할 수 없는 경우, 이 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 반환할 수 있는 데이터가 없음을 나타낸다.

Non Blocking I/O에 액세스하는 가장 기본적인 패턴은 실제 데이터가 반환될 때가지 루프 내에서 리소스를 적극적으로 폴링(poll)하는 것이다. 이 것을 **busy-waiting** 이라고 한다.

아래 의사 코드는 논 블로킹 I/O 및 폴링 루프를 사용하여 여러 리소스에서 읽는 방법을 보여준다.

```
resources = [socketA, socketB, pipeA];
while(!resources.isEmpty()) {
  for( i = 0; i < resources.length; i++) {
    resource = resources[i];
    // 읽기 시도
    let data = resource.read();
    if(data === NO_DATA_AVAILABLE) //당장 읽을 데이터가 없음
      continue;
    if(data === RESOURCE_CLOSED) //데이터 리소스가 닫혔으므로 리소스 목록에서 제거
      resources.remove(i);
    else // 데이터가 도착하여 이를 처리
      consumeData(data);
  }
}
```

이 간단한 기술로 동일한 스레드에서 서로 다른 리소스를 처리할 수 있지만, 비효율적임을 알 수 있다. 실제로 위의 루프는 대부분의 경우 사용할 수 없는 리소스를 반복하여 CPU를 낭비한다. 폴링 알고리즘은 대부분 엄청난 양의 CPU 시간 낭비를 초래한다. 

### 1.3.4 이벤트 디멀티플렉싱

- Busy-wating은 논 블로킹 리소스를 처리하기 위한 이상적인 기술은 아니지만 대부분의 최신 운영체제는 효율적인 논 블로킹 리소스 처리를 위한 기본적인 매커니즘을 제공하는데 이 매커니즘을 **동기 이벤트 디멀티플렉서** 또는 **이벤트 통지 인터페이스**라고 한다. 
- 이 구성 요소는 감시된 일련의 리소스들로부터 들어오는 I/O 이벤트를 수집하여 큐에 넣고 처리할 수 있는 새 이벤트가 있을 때까지 차단한다.

아래는 두 개의 서로 다른 자원에서 일기위해 일반 동기 이벤트(generic synchronous event) 디머리플렉서를 사용하는 알고리즘의 의사 코드이다.

```
socketA, pipeB;
watchedList.add(socketA, FOR_READ); //[1]
watchedList.add(pipeB, FOR_READ);
while(events = demultiplexer.watch(watchedList)) { //[2]
  //이벤트 루프
  foreach(event in events) { //[3]
    // 여기서 read는 블록되지 않으며 비어 있을지언정, 항상 데이터를 반환한다.
    data = event.resource.read();
    if(data === RESOURCE_CLOSED) // 리소스가 닫혔기 때문에, 리소스 목록에서 제거한다.
      demultiplexer.unwatch(event.resource);
    else // 실제 데이터가 도착하여 이를 처리한다.
      consumeData(data);
  }
}
```

위 의사 코드의 주요 과정은 아래와 같다.

1. 리소스를 데이터 구조(List)에 추가한다. 예제에서는 각 인스턴스를 특정 작업(ex: read)과 연결한다.
2. 이벤트 통지자에 감시할 리소스 그룹을 설정한다. 이 호출은 동기식이며, 감시 대상 자원 중 하나라도 읽을 준비가 될 때까지 차단된다. 이 경우, 이벤트 디멀티플렉서는 호출로부터 복귀하여 새로운 일련의 이벤트들을 처리할 수 있게 된다.
3. 이벤트 디멀티플렉서에 의해 반환된 각 이벤트가 처리된다. 이 시점에서 각 이벤트와 관련된 리소스는 읽기 작업을 위한 준비가 되어 있으며, 차단되지 않은 상황이라는 것이 보증된다. 모든 이벤트가 처리되고 나면, 이 흐름을 다시 디멀티플렉서에서 처리 가능한 이벤트가 발생할 때까지 차단된다. 이를 이벤트 루프(event loop)라고 한다.

이 패턴을 사용하면 바쁜 대기(Busy-wating) 기술을 사용하지 않고도 단일 스레드 내에서 여러 I/O작업을 처리할 수 있다.  아래 그림은 웹 서버가 동기 이벤트 디멀티플렉서와 단일 스레드를 사용하여 여러 연결을 처리하는 방법을 보여준다.

![스크린샷 2019-05-13 오전 10.02.36](/Users/wook/Desktop/스크린샷 2019-05-13 오전 10.02.36.png)

위 이미지는 동기 이벤트 디멀티플렉서 및 논 블로킹 I/O를 사용하여 단일 스레드 어플리케이션에서 동시성이 작동하는 방식을 이해하기 쉽도록 한다. 하나의 스레드만 사용하더라도 다중 I/O 사용 작업을 동시에 실행할 수 있는 능력을 손상시키지 않는다. 작업은 여러 스레드로 분산되지 않고 시간에 따라 분산된다. 이는 이미지에 명확하게 표시된 것처럼 스레드의 총 유휴 시간으 ㄹ최소화하는 명백한 장점이 있다. 이것이 이 모델을 선택하는 유일한 이유는 아니다. 사실 하나의 스레드만 갖는다는 것은 프로그래머가 일반적으로 동시성에 접근하는 방식에 유익한 영향을 미친다.

