---
title: "[1. Node.js에 대해서] 1.3 React Pattern"
date: 2019-05-07 09:46:00
categories: nodejs designpattern
comments: true

---

## 1.3 React Pattern

Node.js의 비동기 특성의 핵심인 React 패턴을 분석한다. 단일 스레드 아키텍쳐 및 블로킹 I/O와 같은 패턴의 기본 개념을 살펴보고, 이것이 Node.js 플랫폼 전체에 대한 기반을 형성하는 방법을 살펴본다.

### 1.3.1 I/O는 속도가 느리다.

- I/O는 컴퓨터의 기본적인 동작 중에서 가장 느리다.
- I/O는 일반적으로 CPU 측면에서 비용이 많이 들지 않지만, 요청을 보낸 순간부터 작업이 완료되는 순간까지 지연을 동반하게 된다.
- 또한 어플리케이션의 입력은 실시간 채팅 어플리케이션에서 전송 버튼이나 메시지 클릭과 같은 실제 사람의 입력이므로 I/O의 속도와 빈도는 기술적인 면에만 의존하지 않는다. 이는 디스크 또는 네트워크보다 훨씬 더 느리게 진행될 수 있다.

### 1.3.2 Blocking I/O

- 전통적인 블로킹 I/O 프로그래밍에서는 I/O 요청이 해당하는 함수 호출은 작업이 완료될 때까지 스레드의 실행이 차단된다. 
- 디스크 액세스의 경우 몇 밀리 초에서 키를 누르는 것과 같은 사용자 조작으로 생성되는 데이터의 경우 몇 분 또는 그 이상이 걸릴 수 도 있다.

다음 의사 코드는 소켓에 대해 수행되는 일반적인 블로킹 스레드를 보여준다.

```javascript
//데이터를 사용할 수 있을 때까지 스레드가 블록된다.
data = socket.read();
//데이터 사용 가능
print(data);
```

- 각 소켓에서의 모든 I/O 작업이 다른 연결 처리를 차단하기 때문에 블로킹 I/O를 사용하여 구현된 웹 서버가 동일한 스레드에서 여러 연결을 처리할 수 없다.
- 따라서 웹 서버에서 동시성을 처리하기 위한 전통적인 접근 방식은 처리해야 하는 각각의 동시 연결에 대해 새로운 스레드 또는 프로세스를 시작하거나 풀에서 가져온 스레드를 재사용하는 것이다.
- 이렇게 해서 스레드가 I/O 작업으로 차단되어도 분리된 스레드에서 처리되므로 다른 요청의 가용성에는 영향을 미치지 않는다.

아래 그림은 이 시나리오를 보여주고 있다.

![1_3_image1](https://firstwook.github.io/assets/img/1_3_image1.png)

위 이미지는 각 스레드가 관련 연결로부터 새로운 데이터가 수신되기를 기다리는 유휴 상태에 중점을 두고 있다. 예를 들어, 데이터베이스나 파일 시스템과 상호 작용할 때와 같이 모든 유형의 I/O가 요청의 처리를 차단할 수 있다고 생각한다면, 곧 스레드가 얼마나 많이 I/O 조작의 결과를 기다리기 위해 차단되는지 그 횟수를 알 수 있다. 불행히 스레드는 시스템 리소스 측면에서 비용이 싸지 않다. 메모리를 소비하고 컨텍스트 전환을 유발하므로, 각 연결에 대해 대부분의 시간을 사용하지 않으면서 장시간 실행되는 스레드를 사용하는 것은 효율성 측면에서 최상의 절충안은 아니다.

### 1.3.3 Non Blocking I/O

- 대부분의 최신 운영체제는 리소스를 액세스 하는 데에 있어 논 블로킹 I/O 매커니즘을 사용한다.
- 이 운영 모드에서 시스템 호출은 데이터가 읽히거나 쓰여질때까지 기다리지 않고 항상 즉시 반환한다.
- 호출하는 순간에 결과를 사용할 수 없는 경우, 이 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 반환할 수 있는 데이터가 없음을 나타낸다.

Non Blocking I/O에 액세스하는 가장 기본적인 패턴은 실제 데이터가 반환될 때가지 루프 내에서 리소스를 적극적으로 폴링(poll)하는 것이다. 이 것을 **busy-waiting** 이라고 한다.

아래 의사 코드는 논 블로킹 I/O 및 폴링 루프를 사용하여 여러 리소스에서 읽는 방법을 보여준다.

```
resources = [socketA, socketB, pipeA];
while(!resources.isEmpty()) {
  for( i = 0; i < resources.length; i++) {
    resource = resources[i];
    // 읽기 시도
    let data = resource.read();
    if(data === NO_DATA_AVAILABLE) //당장 읽을 데이터가 없음
      continue;
    if(data === RESOURCE_CLOSED) //데이터 리소스가 닫혔으므로 리소스 목록에서 제거
      resources.remove(i);
    else // 데이터가 도착하여 이를 처리
      consumeData(data);
  }
}
```

이 간단한 기술로 동일한 스레드에서 서로 다른 리소스를 처리할 수 있지만, 비효율적임을 알 수 있다. 실제로 위의 루프는 대부분의 경우 사용할 수 없는 리소스를 반복하여 CPU를 낭비한다. 폴링 알고리즘은 대부분 엄청난 양의 CPU 시간 낭비를 초래한다. 

### 1.3.4 이벤트 디멀티플렉싱

- Busy-wating은 논 블로킹 리소스를 처리하기 위한 이상적인 기술은 아니지만 대부분의 최신 운영체제는 효율적인 논 블로킹 리소스 처리를 위한 기본적인 매커니즘을 제공하는데 이 매커니즘을 **동기 이벤트 디멀티플렉서** 또는 **이벤트 통지 인터페이스**라고 한다. 
- 이 구성 요소는 감시된 일련의 리소스들로부터 들어오는 I/O 이벤트를 수집하여 큐에 넣고 처리할 수 있는 새 이벤트가 있을 때까지 차단한다.

아래는 두 개의 서로 다른 자원에서 읽기위해 일반 동기 이벤트(generic synchronous event) 디머리플렉서를 사용하는 알고리즘의 의사 코드이다.

```
socketA, pipeB;
watchedList.add(socketA, FOR_READ); //[1]
watchedList.add(pipeB, FOR_READ);
while(events = demultiplexer.watch(watchedList)) { //[2]
  //이벤트 루프
  foreach(event in events) { //[3]
    // 여기서 read는 블록되지 않으며 비어 있을지언정, 항상 데이터를 반환한다.
    data = event.resource.read();
    if(data === RESOURCE_CLOSED) // 리소스가 닫혔기 때문에, 리소스 목록에서 제거한다.
      demultiplexer.unwatch(event.resource);
    else // 실제 데이터가 도착하여 이를 처리한다.
      consumeData(data);
  }
}
```

위 의사 코드의 주요 과정은 아래와 같다.

1. 리소스를 데이터 구조(List)에 추가한다. 예제에서는 각 인스턴스를 특정 작업(ex: read)과 연결한다.
2. 이벤트 통지자에 감시할 리소스 그룹을 설정한다. 이 호출은 동기식이며, 감시 대상 자원 중 하나라도 읽을 준비가 될 때까지 차단된다. 이 경우, 이벤트 디멀티플렉서는 호출로부터 복귀하여 새로운 일련의 이벤트들을 처리할 수 있게 된다.
3. 이벤트 디멀티플렉서에 의해 반환된 각 이벤트가 처리된다. 이 시점에서 각 이벤트와 관련된 리소스는 읽기 작업을 위한 준비가 되어 있으며, 차단되지 않은 상황이라는 것이 보증된다. 모든 이벤트가 처리되고 나면, 이 흐름을 다시 디멀티플렉서에서 처리 가능한 이벤트가 발생할 때까지 차단된다. 이를 이벤트 루프(event loop)라고 한다.

이 패턴을 사용하면 바쁜 대기(Busy-wating) 기술을 사용하지 않고도 단일 스레드 내에서 여러 I/O작업을 처리할 수 있다.  아래 그림은 웹 서버가 동기 이벤트 디멀티플렉서와 단일 스레드를 사용하여 여러 연결을 처리하는 방법을 보여준다.

![1_3_image2](https://firstwook.github.io/assets/img/1_3_image2.png)

위 이미지는 동기 이벤트 디멀티플렉서 및 논 블로킹 I/O를 사용하여 단일 스레드 어플리케이션에서 동시성이 작동하는 방식을 이해하기 쉽도록 한다. 하나의 스레드만 사용하더라도 다중 I/O 사용 작업을 동시에 실행할 수 있는 능력을 손상시키지 않는다. 작업은 여러 스레드로 분산되지 않고 시간에 따라 분산된다. 이는 이미지에 명확하게 표시된 것처럼 스레드의 총 유휴 시간으 ㄹ최소화하는 명백한 장점이 있다. 이것이 이 모델을 선택하는 유일한 이유는 아니다. 사실 하나의 스레드만 갖는다는 것은 프로그래머가 일반적으로 동시성에 접근하는 방식에 유익한 영향을 미친다.

### 1.3.5 Reactor 패턴 소개

이전에 제시된 알고리즘에 특수화된 Reactor 패턴을 소개한다. 그 이면에 있는 핵심 개념은 I/O 작업과 관련된 핸들러(Node.js에서 callback 함수로 표시됨)를 갖는 것이다. 이 핸들러는 이벤트가 생성되어 이벤트 루프에 의해 처리되는 즉시 호출된다. 

아래는 Reactor 패턴의 구조를 도식화한 것이다. 

![1_3_image3](https://firstwook.github.io/assets/img/1_3_image3.png)

Reactor 패턴을 사용하는 어플리케이션은 다음과 같은 순서가 발생한다.

1. 어플리케이션은 **이벤트 디멀티플렉서**에 요청을 전달함으로써 새로운 I/O 작업을 생성한다. 또한 어플리케이션은 처리가 완료될 때 호출될 핸들러를 지정한다. **이벤트 디멀티플렉서**에 새 요청을 전달하는 것은 논 블로킹 호출이며, 즉시 어플리케이션에 제어를 반환한다.
2. 일련의 I/O 작업들이 완료되면 **이벤트 디멀티플렉서**는 새 이벤트를 **이벤트 큐**에 집어넣는다.
3. 이 시점에서 **이벤트 루프**가 **이벤트 큐**의 항목들에 대해 반복한다.
4. 각 이벤트에 대해서 관련된 핸들러가 호출된다.
5. 어플리케이션 코드의 일부인 핸들러는 실행이 완료되면 **이벤트 루프**에 제어를 되돌린다(5a). 그러나 핸들러의 실행 중에 새로운 비동기 동작이 요청(5b)이 발생하여 제어가 **이벤트 루프**로 돌아가기 전에 새로운 요청이 **이벤트 디멀티플렉서(1)**에 삽입될 수도 있다.
6. **이벤트 큐** 내의 모든 항목이 처리되면, 루프는 **이벤트 디멀티플렉서**에서 다시 블록되고 처리 가능한 새로운 이벤트가 있을 때 이 과정이 다시 트리거 될 것이다.

위 설명을 토대로 비동기식 동작이 명확해졌다. 어플리케이션은 특정 시점(블로킹 없이)에서 리소스에 액세스하려는 요청을 표시하고, 해당 처리가완료되는 다른 시점에서 호출될 핸들러를 제공한다.

이로써 Node.js의 핵심에 패턴을 다음과 같이 정의할 수 있다.

``패턴(Reactor)은 일련의 관찰 대상 리소스에서 새 이벤트를 사용할 수 있을 때까지 차단하여 I/O를 처리한 다음, 각 이벤트를 관련 핸들러로 전달함으로써 반응한다.``

### 1.3.6 Node.js의 논 블로킹 엔진 libuv

- 각 운영체제(Linux, Mac OS, Window ..)는 **이벤트 디멀티플렉서**에 대한 자체 인터페이스가 있고, 각 I/O 작업은 동일한 OS 내에서도 리소스 유형에 따라 다르게 작동할 수 있다.
- 서로 다른 운영체제에서 발생하는 불일치로 인해 이벤트 디멀티플렉서에 대한 보다 높은 수준의 추상화가 필요한데, 이것이 바로 Node.js 코어 팀이 **libuv**라는 C 라이브러리를 만든 이유이다.
- 이를 통해 모든 주요 플랫폼과 호환되고, 서로 다른 유형의 리소스들의 논 블로킹 동작을 표준화 할 수 있을 것이다.
- 오늘날 libuv는 Node.js의 하위 수준의 I/O 엔진을 나타낸다.
- libuv는 기본 시스템 호출을 추상화하는 것 외에도 Reactor 패턴을 구현하고 있으므로 이벤트 루프를 만들고, 이벤트 큐를 관리하며, 비동기 입출력 작업을 실행하고, 다른 유형의 작업을 큐에 담기 위한 API들을 제공한다.

### 1.3.7 Node.js를 위한 구조

리액터 패턴과 libuv가 Node.js의 기본 구성 요소이지만 전체 플랫폼을 구축하려면 아래의 세가지 구성 요소가 필요하다

1. libuv와 기타 낮은 수준의 기능들을 JavaScript에 래핑하고 사용 가능하도록 해주는 바인딩 세트
2. V8, 이것은 원래 Google에서 Chrome 브라우저 용으로 개발한 JavaScript 엔진이다. 이것이 Node.js가 매우 빠르고 효율적인 이유 중하나이다. V8은 혁신적인 설계와 속도 그리고 효율적인 메모리 관리로 높은 평가를 받고 있다.
3. 상위 수준의 Node.js API를 구현하고 있는 코어 JavaScript 라이브러리(노드 코어라고 함).

이것들이 Node.js의 구성이며, 아래 이미지는 최종 아키텍처를 묘사하고 있다.

![1_3_image4](https://firstwook.github.io/assets/img/1_3_image4.png)