---
title: "[1. Node.js에 대해서] 1.3 React Pattern"
date: 2019-05-07 09:46:00
categories: nodejs designpattern


---

## 1.3 React Pattern

Node.js의 비동기 특성의 핵심인 React 패턴을 분석한다. 단일 스레드 아키텍쳐 및 블로킹 I/O와 같은 패턴의 기본 개념을 살펴보고, 이것이 Node.js 플랫폼 전체에 대한 기반을 형성하는 방법을 살펴본다.

### 1.3.1 I/O는 속도가 느리다.

- I/O는 컴퓨터의 기본적인 동작 중에서 가장 느리다.
- I/O는 일반적으로 CPU 측면에서 비용이 많이 들지 않지만, 요청을 보낸 순간부터 작업이 완료되는 순간까지 지연을 동반하게 된다.
- 또한 어플리케이션의 입력은 실시간 채팅 어플리케이션에서 전송 버튼이나 메시지 클릭과 같은 실제 사람의 입력이므로 I/O의 속도와 빈도는 기술적인 면에만 의존하지 않는다. 이는 디스크 또는 네트워크보다 훨씬 더 느리게 진행될 수 있다.

### 1.3.2 Blocking I/O

- 전통적인 블로킹 I/O 프로그래밍에서는 I/O 요청이 해당하는 함수 호출은 작업이 완료될 때까지 스레드의 실행이 차단된다. 
- 디스크 액세스의 경우 몇 밀리 초에서 키를 누르는 것과 같은 사용자 조작으로 생성되는 데이터의 경우 몇 분 또는 그 이상이 걸릴 수 도 있다.

다음 의사 코드는 소켓에 대해 수행되는 일반적인 블로킹 스레드를 보여준다.

```javascript
//데이터를 사용할 수 있을 때까지 스레드가 블록된다.
data = socket.read();
//데이터 사용 가능
print(data);
```

- 각 소켓에서의 모든 I/O 작업이 다른 연결 처리를 차단하기 때문에 블로킹 I/O를 사용하여 구현된 웹 서버가 동일한 스레드에서 여러 연결을 처리할 수 없다.
- 따라서 웹 서버에서 동시성을 처리하기 위한 전통적인 접근 방식은 처리해야 하는 각각의 동시 연결에 대해 새로운 스레드 또는 프로세스를 시작하거나 풀에서 가져온 스레드를 재사용하는 것이다.
- 이렇게 해서 스레드가 I/O 작업으로 차단되어도 분리된 스레드에서 처리되므로 다른 요청의 가용성에는 영향을 미치지 않는다.

아래 그림은 이 시나리오를 보여주고 있다.

![image1](/Users/wook/Desktop/image1.png)

위 이미지는 각 스레드가 관련 연결로부터 새로운 데이터가 수신되기를 기다리는 유휴 상태에 중점을 두고 있다. 예를 들어, 데이터베이스나 파일 시스템과 상호 작용할 때와 같이 모든 유형의 I/O가 요청의 처리를 차단할 수 있다고 생각한다면, 곧 스레드가 얼마나 많이 I/O 조작의 결과를 기다리기 위해 차단되는지 그 횟수를 알 수 있다. 불행히 스레드는 시스템 리소스 측면에서 비용이 싸지 않다. 메모리를 소비하고 컨텍스트 전환을 유발하므로, 각 연결에 대해 대부분의 시간을 사용하지 않으면서 장시간 실행되는 스레드를 사용하는 것은 효율성 측면에서 최상의 절충안은 아니다.

### 1.3.3 Non Blocking I/O

- 대부분의 최신 운영체제는 리소스를 액세스 하는 데에 있어 논 블로킹 I/O 매커니즘을 사용한다.
- 이 운영 모드에서 시스템 호출은 데이터가 읽히거나 쓰여질때까지 기다리지 않고 항상 즉시 반환한다.
- 호출하는 순간에 결과를 사용할 수 없는 경우, 이 함수는 단순히 미리 정의된 상수를 반환하여 그 순간에 반환할 수 있는 데이터가 없음을 나타낸다.

Non Blocking I/O에 액세스하는 가장 기본적인 패턴은 실제 데이터가 반환될 때가지 루프 내에서 리소스를 적극적으로 폴링(poll)하는 것이다. 이 것을 **busy-waiting** 이라고 한다.

아래 의사 코드는 논 블로킹 I/O 및 폴링 루프를 사용하여 여러 리소스에서 읽는 방법을 보여준다.

```
resources = [socketA, socketB, pipeA];
while(!resources.isEmpty()) {
  for( i = 0; i < resources.length; i++) {
    resource = resources[i];
    // 읽기 시도
    let data = resource.read();
    if(data === NO_DATA_AVAILABLE) //당장 읽을 데이터가 없음
      continue;
    if(data === RESOURCE_CLOSED) //데이터 리소스가 닫혔으므로 리소스 목록에서 제거
      resources.remove(i);
    else // 데이터가 도착하여 이를 처리
      consumeData(data);
  }
}
```

이 간단한 기술로 동일한 스레드에서 서로 다른 리소스를 처리할 수 있지만, 비효율적임을 알 수 있다. 실제로 위의 루프는 대부분의 경우 사용할 수 없는 리소스를 반복하여 CPU를 낭비한다. 폴링 알고리즘은 대부분 엄청난 양의 CPU 시간 낭비를 초래한다. 