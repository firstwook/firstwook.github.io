---
title: "[2. Node.js 필수 패턴] 2.1 Callback Pattern"
date: 2019-05-07 09:46:00
categories: nodejs designpattern
comments: true

---

## 2.1 Callback Pattern

콜백은 리액터 패턴 핸들러를 구현한 것이다. 또한 Node.js에 독특한 프로그래밍 스타일을 제공하는 상징 중 하나이다. 콜백은 작업 결과를 전달하기 위해 호출되는 함수이며, 비동기 작업을 처리할 때 반드시 필요하다. 이들은 항상 동기적으로 실행되는 return 명령의 사용을 대신한다. JavaScript는 콜백을 표현할 수 있는 훌륭한 언어이다. 함수가 일급 클래스 객체(first class object)여서 변수에 쉽게 할당하거나, 인수로 전달되거나, 다른 함수 호출에서 반환되거나 자료구조에 저장될 수 있기 때문이다. 콜백을 구현하는 또 다른 이상적인 구조는 클로저(Closures)이다. 클로저를 사용하면 실제로 함수가 작성된 환경을 참조할 수 있다. 콜백이 언제 어디서 호출되는 지에 관계없이 비동기 작업이 요청된 커텍스트를 항상 유지할 수 있기 때문이다.

`` 클로저에 대한 설명 참고 :  https://opentutorials.org/course/743/6544 ``

### 2.1.1 연속 전달 방식(The Continuation-Passing Style)

- JavaScript에서 콜백은 다른 함수에 인수로 전달되는 함수이며, 작업이 완료되면 결과로 호출된다. 함수형 프로그래밍에서 결과를 전달하는 방식을 **연속 전달 방식(CPS)**이라고 한다.
- **연속 전달 방식(CPS)** 은 일반적인 개념으로, 항상 비동기 작업과 관련이 있는 것은 아니다. 단순히 결과를 호출자에게 직접 반환하는 대신 다른 함수(콜백)로 전달함으로써 결과를 전달하는 것을 말한다. 

### **동기식 연속 전달 방식**

```javascript
function add(a, b) {
	return a + b;
}
```

위는 결과를 return 문을 통해 호출자에게 전달하는 간단한 동기 함수를 나타낸다. 이것을 **직접 스타일(direct style)**이라고 하며, 동기화 프로그래밍에서 일반적으로 결과를 반환하는 방식을 보여준다.

```javascript
function add(a, b, callback) {
	callback(a + b);
}
```

위는 직접 스타일로 작성된 동기 함수를 연속 전달 방식으로 바꾼 코드이다. add() 함수는 동기화된 CPS 함수로 콜백이 완료될 때만 값을 반환한다.

아래 코드는 사용 방법을 보여준다.

```javascript
function add(a, b, callback) {
	callback(a + b);
}

console.log('before');
add(1, 2, result => { console.log('Result: ', + result) });
console.log('after');

======================= 출력 결과 =======================
before
result : 3
after
```

add()가 동기 함수이므로 순서대로 출력한다.

###**비동기식 연속 전달 방식**

```javascript
function additionAsync(a, b, callback) {
	setTimeout(() => callback(a + b), 100);
}

console.log('before');
additionAsync(1, 2, result => { console.log('Result: ', + result) });
console.log('after');


======================= 출력 결과 =======================
before
after
Result:  3
```

동기식으로 작성되었던 add() 함수를 비동기적으로 작동하는 예시를 보이기 위해 setTimeout()을 사용하여 콜백의 비동기 호출을 가정했다. additionAsync를 사용하면 출력 결과는 위와 같이 나온다. setTimeout()은 비동기 작업을 실행시키기 때문에 콜백의 실해이 끝날 때까지 기다리지 않는 대신, 즉시 반환되어 additionAsync()로 제어를 돌려주어 제어가 호출자에게 반환된다. Node.js의 이 속성은 비동기 요청이 전달된 후 즉시 제어를 이벤트 루프에 돌려주어 큐(대기열)에 있는 새로운 이벤트가 처리도리 수 있도록 하기 때문에 매우 중요하다.

작동방식은 아래와 같다.

![2_1_image1](https://firstwook.github.io/assets/img/2_1_image1.png)

비동기 작업이 완료되면 실행은 비동기 함수에 제공된 콜백에서부터 다시 계속된다. 실행은 **이벤트 루프**에서 시작되기 떄문에 새로운 스택을 갖는다. 클로저 덕분에 콜백이 다른 시점과 다른 위치에서 호출되더라도 비동기 함수의 호출자 컨텍스트를 유지하므로 JavaScript가 유용한 지점이다.

동기 함수는 조작을 완료할 때까지 블록한다. 비동기 함수는 제어를 즉시 반환하고 결과는 이벤트 루프의 다음 사이클에서 핸들러(이 경우에는 콜백)로 전달된다.

###**비 연속 전달(Non-continuation-passing) 방식의 콜백**

함수에 콜백 인자가 있으면, 함수가 비동기식이거나 연속 전달 스타일(CPS)을 사용한다고 가정할 수 있다. 그러나 항상 그런 것은 아니다. 

```javascript
const result = [1, 5, 7].map(element => element - 1);
console.log(result); //[ 0, 4, 6 ]
```

위의 예시와 같이 Array 객체의 map() 함수를 사용한 예를 보면, 콜백은 배열 내의 요소를 반복하는데 사용될 뿐 연산 결과를 전달하지 않는다. 실제 여기서 결과는 직접적인 방식으로 동기적으로 반환한다. 보통 사용하려는 함수에 대해, 해당 함수의 콜백의 목적은 API 문서에 분명하게 명시된다.

###2.1.2 동기냐? 비동기냐?

- 동기식이과 비동기식 둘 모두 피해야 할 것은 API의 이러한 특성과 관련하여 모순과 혼돈을 만드는 것이다.
- 그렇게 하면 발견하기 어렵고 재현이 불가능한 문제를 야기할 수 있다.

### **예측할 수 없는 함수**

가장 위험한 상황 중 하나는 특정 조건에서 동기적으로 동작하고 다른 조건에서는 비동기적으로 동작하는 API를 갖는 것이다.

```javascript
const fs = require('fs');
const cache = {};
function inconsistentRead(filename, callback){
  if(cache[filename]){
    //동기적으로 호출됨
    callback(cache[filename]);
  }else {
    //비동기함수
    fs.readFile(filename, 'utf8', (err, dadta) => {
      cache[filename] = data;
      callback(data);
    });
  }
}
```

앞의 함수는 cache 변수를 사용하여 서로 다른 파일을 읽어 작업의 결과를 저장한다. ~~위는 예제일 뿐, 오류 관리도 없고, 캐싱 로직 자체가 꼭 이렇게 되는 것은 아니다.~~ 

